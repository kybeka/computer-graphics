<html>
    <head>
        <meta charset="UTF-8">
        <script src="gl-matrix-min.js"></script>
        <script src="geometry.js"></script>
        <script type="text/javascript">

            var vertexShaderCode =
                `#version 300 es
                in vec3 a_position;
                in vec3 a_color;
                in vec3 a_normal;

                out vec3 v_color;
                out vec3 v_normal;

                // uniform mat4 rotationMatrix; // required for the solution of the previous assignment, please remove

                // Exercise 1: add uniforms for all transformation matrices
                uniform mat4 scaleMatrix;
                uniform mat4 rotationMatrix;
                uniform mat4 translationMatrix;

                uniform mat4 viewMatrix;
                uniform mat4 projectionMatrix;


                // Exercise 3: add input attribute for normals
                //             add output variables required for light computation, e.g., normal, view direction etc.
                //             add here also a uniform for light direction, unless you pass it directly to the fragment shader

                out vec3 v_view_direction;
                out vec3 v_direction_to_plight;
                out float v_distance;

                uniform vec3 plight_position;

                void main(){
                    v_color = a_color;
                    v_normal = a_normal;
                    mat4 modelMatrix = translationMatrix * rotationMatrix * scaleMatrix;

                    // compute all the variables required for light computation in the fragment shader
                    // remember that all the locations and vectors have to be in a common space, e.g., eye/camera space

                    v_direction_to_plight = normalize(plight_position - vec3(modelMatrix * vec4(a_position, 1.0)));

                    v_distance = max(0.1f, length(plight_position - vec3(modelMatrix * vec4(a_position, 1.0))));

                    // replace the rotationMatrix with correct transformations
                    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position,1.0);
                    v_normal = vec3(rotationMatrix * vec4(a_normal, 0.0));
                    v_view_direction = -vec3(modelMatrix * vec4(a_position, 1.0));
                }`;

            var fragmentShaderCode =
                `#version 300 es
                precision mediump float;

                in vec3 v_color;
                in vec3 v_normal;
                in vec3 v_view_direction;
                out vec4 out_color;

                // Exercise 3: add all the input variable passed from the vertex shader
                //             if the do not include the light direction, you should add here an additional uniform for it
                //             you can also add here constants for Phong shading model, e.g., light color, ambient, diffuse, and specular coefficients, gamma value, as well as shininess

                uniform vec3 dlight_direction;
                uniform vec3 dlightColor;

                in vec3 v_direction_to_plight;
                in float v_distance;
                uniform vec3 plightColor;

                const float ambient_c = 0.1;
                const float diffuse_c = 0.5;
                const float specular_c = 0.2;
                const float shininess_c = 50.0;

                const float alpha = 1.3f;
                const float beta = 1.8f;
                const float gamma = 1.8f;
            
                vec3 compute_directional_lighting() {
                    vec3 final_color = vec3(0,0,0);

                    vec3 l = normalize(dlight_direction);
                    float diffuse = max(dot(l, v_normal), 0.0); 
                    vec3 h = normalize(l);

                    float specular = pow(max(dot(v_normal, h), 0.0), 4.0*shininess_c);
                    final_color += dlightColor*(diffuse_c*diffuse*v_color + specular_c*specular);
                    return final_color;
                }

                vec3 compute_point_lighting() {
                    vec3 final_color = vec3(0,0,0);

                    vec3 l = normalize(v_direction_to_plight); // direction from the point to the light source
                    float diffuse = max(dot(l, v_normal), 0.0); 
                    vec3 h = normalize(l + v_view_direction);
                    float specular = pow(max(dot(h, v_normal), 0.0), 4.0 * shininess_c);
                    final_color += plightColor * (diffuse_c*diffuse + specular_c*specular);

                    float attenuation = 1.0/pow(v_distance,2.0);
                    return final_color*attenuation;
                }

                void main(){
                    vec3 final_color = compute_directional_lighting() + compute_point_lighting() + ambient_c * v_color;
                    
                    // Tone mapping
                    vec3 tonemapped = alpha * pow(pow(final_color, vec3(beta,beta,beta)), vec3(1.0/gamma,1.0/gamma,1.0/gamma));
                    out_color = vec4(clamp(tonemapped, vec3(0,0,0), vec3(1,1,1)), 1.0);
                }`;


            var gl; // WebGL context
            var shaderProgram; // the GLSL program we will use for rendering

            var cube_vao; // the vertex array object for the cube

            // Exercise 2: you may want to add here variable for VAO of plane and sphere
            var plane_vao; // vertex array for plane
            var sphere_vao; // vertex array object for sphere
            var plightphere_vao; // vertex array object for point light

            // The function initilize the WebGL canvas
            function initWebGL(){
                var canvas = document.getElementById("webgl-canvas");
                gl = canvas.getContext("webgl2");

                //keep the size of the canvas for leter rendering
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;

                //check for errors
                if(gl){
                    console.log("WebGL succesfully initialized.");
                }else{
                    console.log("Failed to initialize WebGL.")
                }
            }

            // This function compiles a shader
            function compileShader(shader, source, type, name = ""){
                // link the source of the shader to the shader object
                gl.shaderSource(shader,source);
                // compile the shader
                gl.compileShader(shader);
                // check for success and errors
                let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if(success){
                    console.log(name + " shader compiled succesfully.");
                }else{
                    console.log(name + " vertex shader error.")
                    console.log(gl.getShaderInfoLog(shader));
                }
            }

            // This function links the GLSL program by combining different shaders
            function linkProgram(program,vertShader,fragShader){
                // attach vertex shader to the program
                gl.attachShader(program,vertShader);
                // attach fragment shader to the program
                gl.attachShader(program,fragShader);
                // link the program
                gl.linkProgram(program);
                // check for success and errors
                if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.log("The shaders are initialized.");
                }else{
                    console.log("Could not initialize shaders.");
                }
            }

            function createGLSLPrograms(){
                var vertexShader = gl.createShader(gl.VERTEX_SHADER);
                compileShader(vertexShader, vertexShaderCode, gl.VERTEX_SHADER, "Vertex shader");
                // Creating fragment shader
                var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                compileShader(fragmentShader, fragmentShaderCode, gl.VERTEX_SHADER, "Fragment shader");
                // Creating and linking the program
                shaderProgram = gl.createProgram();
                linkProgram(shaderProgram, vertexShader, fragmentShader);
            }

            // Excercies 2:
            // Since one has to repeat creating VAO of each object (cube, plane, sphere) separately,
            // we suggest implement a function which takes the arrays containing values of the attributes,
            // and then, creates VBOa, VAOs, and sets up the attributes.
            // This should later simplify your code in initBuffers() to something like:
            //      cube_vao = gl.createVertexArray();
            //      createVAO(cube_vao, shaderProgram, cube_vertices, cube_normals, cube_colors);
            //      sphere_vao = gl.createVertexArray();
            //      createVAO(sphere_vao, shaderProgram, sphere_vertices, sphere_vertices, sphere_colors);
            //      plane_vao = gl.createVertexArray();
            //      createVAO(plane_vao, shaderProgram, plane_vertices, plane_normals, plane_colors);
            function createVAO(vao, shader, vertices, colors, normals){
                // buffer for positions
                let vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

                // a buffer for colors
                let colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

                // a buffer for normals
                let normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

                // bind the VAO
                gl.bindVertexArray(vao);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                var positionAttributeLocation = gl.getAttribLocation(shader, "a_position");
                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                var colorAttributeLocation = gl.getAttribLocation(shader, "a_color");
                gl.enableVertexAttribArray(colorAttributeLocation);
                gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                var normalAttributeLocation = gl.getAttribLocation(shader, "a_normal");
                gl.enableVertexAttribArray(normalAttributeLocation);
                gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT, false, 0, 0);

                return {
                    vertexBuffer,
                    colorBuffer,
                    normalBuffer,
                    positionAttributeLocation,
                    colorAttributeLocation,
                    normalAttributeLocation
                }
            }

            // -------------------------------------------------------------------------------------------------- //
            // Using the same logic from our C tracer, I saw an implementation using helper functions
            // for transforming the necessary matrices
            function getScalingMat(vec3Scale=vec3.fromValues(1,1,1), baseMat=mat4.create()) {
                let resMat = mat4.create()
                mat4.scale(resMat, baseMat, vec3Scale);
                return resMat;
            }

            function getTranslationMat(vec3Translation=vec3.fromValues(0,0,0), baseMat=mat4.create() ) {
                let resMat = mat4.create()
                mat4.translate(resMat, baseMat, vec3Translation);
                return resMat;
            }

            function getRotationMat(vec3Rotation=vec3.fromValues(0,0,0), baseMat=mat4.create()) {
                let resMat = mat4.create();
                let resMatx = mat4.create();
                let resMaty = mat4.create();
                let resMatz = mat4.create();
                
                mat4.fromRotation(resMatx, vec3Rotation[0], vec3.fromValues(1,0,0));
                mat4.fromRotation(resMaty, vec3Rotation[1], vec3.fromValues(0,1,0));
                mat4.fromRotation(resMatz, vec3Rotation[2], vec3.fromValues(0,0,1));

                mat4.multiply(resMat, resMaty, resMatz);
                mat4.multiply(resMat, resMat, resMatx);

                return resMat;
            }

            function getTransformationMat(vec3Translation, vec3Rotation, vec3Scale) {
                return getScalingMat(vec3Scale,getRotationMat(vec3Rotation,getTranslationMat(vec3Translation)));
            }

            function setTransformationUniforms(vec3Translation, vec3Rotation, vec3Scale) {
                const translateMat = getTranslationMat(vec3Translation);
                const rotationMat = getRotationMat(vec3Rotation);
                const scaleMat = getScalingMat(vec3Scale);

                let translationlMatLocation = gl.getUniformLocation(shaderProgram,"translationMatrix");
                gl.uniformMatrix4fv(translationlMatLocation, false, translateMat);

                let rotationMatLocation = gl.getUniformLocation(shaderProgram,"rotationMatrix");
                gl.uniformMatrix4fv(rotationMatLocation, false, rotationMat);

                let scaleMatLocation = gl.getUniformLocation(shaderProgram,"scaleMatrix");
                gl.uniformMatrix4fv(scaleMatLocation, false, scaleMat);
            }


            // used for the point light
            function replace_colors(vertex_colors, vec3Color) {
                return Array(vertex_colors.length/3).fill([vec3Color[0],vec3Color[1],vec3Color[2]]).flat()
            }

            // -------------------------------------------------------------------------------------------------- //

            function initBuffers(){
                cube_vao = {VAO: gl.createVertexArray()};
                cube_vao = {...cube_vao, ...createVAO(cube_vao.VAO, shaderProgram, cube_vertices, cube_colors, cube_normals)};

                plane_vao = {VAO: gl.createVertexArray()};
                plane_vao = {...plane_vao, ...createVAO(plane_vao.VAO, shaderProgram, plane_vertices, plane_colors, plane_normals)};

                sphere_vao = {VAO: gl.createVertexArray()};
                sphere_vao = {...sphere_vao, ...createVAO(sphere_vao.VAO, shaderProgram, sphere_vertices, sphere_colors, sphere_normals)};

                plightphere_vao = {VAO: gl.createVertexArray()};
                plightphere_vao = {...plightphere_vao, ...createVAO(plightphere_vao.VAO, shaderProgram, sphere_vertices, sphere_colors, sphere_normals)};
            }

            function draw(){
                // input variables for controling camera and light parameters
                // feel free to use these or create your own
                let camera_azimuthal_angle = document.getElementById("camera_azimuthal_angle").value / 360 * 2 * Math.PI;
                let camera_polar_angle = document.getElementById("camera_polar_angle").value / 360 * 2 * Math.PI;
                let camera_distance = document.getElementById("camera_distance").value / 10;
                let camera_fov = document.getElementById("camera_fov").value / 360 * 2 * Math.PI;
                // directional light
                let dlight_azimuthal_angle = document.getElementById("light_azimuthal_angle").value / 360 * 2 * Math.PI;
                let dlight_polar_angle = document.getElementById("light_polar_angle").value / 360 * 2 * Math.PI;

                // Exercise 1:
                // add computation of camera position
                let camera_x = camera_distance * Math.sin(camera_polar_angle) * Math.cos(camera_azimuthal_angle);
                let camera_y = camera_distance * Math.cos(camera_polar_angle);
                let camera_z = camera_distance * Math.sin(camera_polar_angle) * Math.sin(camera_azimuthal_angle);

                let camera_position = vec3.fromValues(camera_x, camera_y, camera_z);

                // Excercise 3:
                // add computation of light direction
                let dlight_x = Math.sin(dlight_polar_angle) * Math.cos(dlight_azimuthal_angle);
                let dlight_y = Math.cos(dlight_polar_angle);
                let dlight_z = Math.sin(dlight_polar_angle) * Math.sin(dlight_azimuthal_angle);
                let dlight_direction = vec3.fromValues(dlight_x, dlight_y, dlight_z);
                // add computation of view and projection matrices

                let dlight_colorHEX = document.getElementById("dlight_color").value
                let dlight_color = vec3.fromValues(parseInt(dlight_colorHEX.substr(1,2), 16),parseInt(dlight_colorHEX.substr(3,2), 16),parseInt(dlight_colorHEX.substr(5,2), 16))
                vec3.divide(dlight_color, dlight_color, vec3.fromValues(255,255,255))
                // Point light
                let plight_position = vec3.fromValues(document.getElementById("plight_x").value,document.getElementById("plight_y").value,document.getElementById("plight_z").value)
                let plight_colorHEX = document.getElementById("plight_color").value
                let plight_color = vec3.fromValues(parseInt(plight_colorHEX.substr(1,2), 16),parseInt(plight_colorHEX.substr(3,2), 16),parseInt(plight_colorHEX.substr(5,2), 16))
                vec3.divide(plight_color, plight_color, vec3.fromValues(255,255,255))

                let viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix, camera_position, [0, 0, 0], [0, 1, 0]);
                let projectionMatrix = mat4.create();
                mat4.perspective(projectionMatrix, camera_fov, gl.viewportWidth / gl.viewportHeight, 0.01, 1000.0);

                // relevant only for the solutions of the previous assignment (please remove it for this assignment)
                // var rotation = document.getElementById("rotation");
                // var rotationMatrix = mat4.create();
                // mat4.fromRotation(rotationMatrix, -(rotation.value-100)/100*Math.PI, vec3.fromValues(-0.2,1,0));

                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                gl.clearColor(0.2, 0.2, 0.2, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.DEPTH_TEST);

                // enable the GLSL program for the rendering
                gl.useProgram(shaderProgram);

                // Tips for drawing:
                // - Before drawing anything using the program you still have to set values of all uniforms.
                // - As long as you use the same shader program you do not need to set all uniforms everytime you draw new object. The programs remembers the uniforms after calling gl.drawArrays
                // - The same, if you draw the same object, e.g., cube, multiple times, you do not need to bind the corresponding VAO everytime you draw.

                // Set uniforms
                let viewMatrixLocation = gl.getUniformLocation(shaderProgram, "viewMatrix");
                gl.uniformMatrix4fv(viewMatrixLocation, false, viewMatrix);

                let projectionMatrixLocation = gl.getUniformLocation(shaderProgram, "projectionMatrix");
                gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

                // Directional Light
                let dlightDirectionLocation = gl.getUniformLocation(shaderProgram, "dlight_direction");
                gl.uniform3fv(dlightDirectionLocation, dlight_direction);

                let dlightColorLocation = gl.getUniformLocation(shaderProgram, "dlightColor");
                gl.uniform3fv(dlightColorLocation, dlight_color);

                // Point Light
                let pLightPositionLocation = gl.getUniformLocation(shaderProgram, "plight_position");
                gl.uniform3fv(pLightPositionLocation, plight_position);

                let plightColorLocation = gl.getUniformLocation(shaderProgram, "plightColor");
                gl.uniform3fv(plightColorLocation, plight_color);



                // Drawing cube
                let cube = -1.5;
                
                // CUBE 1
                gl.bindVertexArray(cube_vao.VAO);
                setTransformationUniforms(
                    vec3.fromValues(0, 1, cube),  // Move the cube along the negative z-axis
                    vec3.fromValues(0,0,0),
                    vec3.fromValues(1, 1, 1)
                );
                gl.drawArrays(gl.TRIANGLES, 0, cube_vertices.length / 3);

                // CUBE 2
                gl.bindVertexArray(cube_vao.VAO);   
                setTransformationUniforms(
                        vec3.fromValues(0,1,Math.abs(cube)),
                        vec3.fromValues(0,0,0),
                        vec3.fromValues(1,1,1))
                gl.drawArrays(gl.TRIANGLES, 0, cube_vertices.length/3);
                
                // PLANE
                gl.bindVertexArray(plane_vao.VAO);;
                setTransformationUniforms(
                    vec3.fromValues(0,0.5,0),
                    vec3.fromValues(0,0,0),
                    vec3.fromValues(5,5,5))
                gl.drawArrays(gl.TRIANGLES, 0, plane_vertices.length/3);

                // SPHERE
                gl.bindVertexArray(sphere_vao.VAO);
                setTransformationUniforms(
                    vec3.fromValues(0,1,0),
                    vec3.fromValues(0,0,0),
                    vec3.fromValues(1,1,1))
                gl.drawArrays(gl.TRIANGLES, 0, sphere_vertices.length/3)   


                // COLORED LIGHT SOURCE SPHERE
                gl.bindVertexArray(plightphere_vao.VAO);
                gl.bindBuffer(gl.ARRAY_BUFFER,plightphere_vao.colorBuffer);
                let newcolors = replace_colors(sphere_colors, plight_color);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(newcolors), gl.STATIC_DRAW);

                setTransformationUniforms(
                    plight_position,
                    vec3.fromValues(0,0,0),
                    vec3.fromValues(0.2,0.2,0.2))
                gl.drawArrays(gl.TRIANGLES, 0, sphere_vertices.length/3);

                window.requestAnimationFrame(function() {draw();});
            }

            function start(){
                // initialze WebGL
                initWebGL();
                // create GLSL programs
                createGLSLPrograms();
                // initialize all the buffers and set up the vertex array objects (VAO)
                initBuffers();
                // draw
                draw();
            }

        </script>
    </head>

    <body onload="start();">
        <canvas id="webgl-canvas" width="768" height="768"></canvas>
        <div  style="float: right">
            <h4>Camera:</h4>
            <div class="slidecontainer">
                Azimuthal angle:</br><input type="range" min="-270" max="90" value="-45" id="camera_azimuthal_angle">
            </div>
            <div class="slidecontainer">
                Polar angle:</br><input type="range" min="1" max="179" value="60" id="camera_polar_angle">
            </div>
            <div class="slidecontainer">
                Distance:</br><input type="range" min="20" max="200" value="50" id="camera_distance">
            </div>
            <div class="slidecontainer">
                Field of view:</br><input type="range" min="10" max="150" value="45" id="camera_fov">
            </div>

            <h4>Directional light:</h4>
            <div class="slidecontainer">
                Azimuthal angle:</br><input type="range" min="-270" max="90" value="-70" id="light_azimuthal_angle">
            </div>
            <div class="slidecontainer">
                Polar angle:</br><input type="range" min="1" max="179" value="60" id="light_polar_angle">
            </div>
            <div class="slidecontainer">
                Color:</br><input type="color" id="dlight_color" value="#FF33CC">
            </div>

            <h4>Point light:</h4>
            <div class="slidecontainer">
                X Coordinate:</br><input type="range" step="0.05" min="-3" max="3" value="0" id="plight_x">
            </div>
            <div class="slidecontainer">
                Y Coordinate:</br><input type="range" step="0.05" min="-3" max="3" value="1.2" id="plight_y">
            </div>
            <div class="slidecontainer">
                Z coordinate:</br><input type="range" step="0.05" min="-3" max="3" value="-1" id="plight_z">
            </div>
            <div class="slidecontainer">
                Color:</br><input type="color" id="plight_color" value="#00FFFF">
            </div>
        </div>
    </body>

</html>
